#!/usr/bin/env pythonimport rospy,math,Image# the message that we get from the arduinofrom std_msgs.msg import Int32# the output message controlling the speed and direction of the robotfrom geometry_msgs.msg import Twistfrom std_msgs.msg import Stringa_list , b_list ,location_b= [],[],[]add,column,row,f=0,0,0,1n,m,position,angular= 0,0,0,0im = Image.new('L',(11000,10000),(255))def ir_callback(data):	global kobuki_velocity_pub,a_pub,b_pub,position_pub	global a_list,b_list,location_b,m,n,add,position,angular	global column,row,f	n += 1	# Twist is a message type in ros, here we use an Twist message to control kobuki's speed	# twist. linear.x is the forward velocity, if it is zero, robot will be static,	# if it is grater than 0, robot will move forward, otherwise, robot will move backward	# twist.angular.axis is the rotatin velocity around the axis	#	# Around which axis do we have to turn? In wich direction will it turn with a positive value?	# Right hand coordinate system: x forward, y left, z up	twist = Twist()	twist.linear.x = 0.02	twist.angular.z = position * 0.2	# write your code here	#print data	data2 = str(bin(int(str(data)[6:])))	a = int(data2[2:-16],2)	b = int(data2[-16:],2)	a_pub.publish(a)	b_pub.publish(b)	a_list.append(a)	b_list.append(b)	if add == 0 and n == 410:		add = 1		location_a = a_list.index(max(a_list))		location_b.append(b_list.index(min(b_list)))		m = location_b[-1] + 20		angle = (location_a -location_b[-1])* math.pi/205		position = angle*200		angular+=angle		twist.angular.z = position*0.02		return	if add == 1 and n-m == 410:		location_b.append(m+b_list[m:].index(min(b_list[-100:])))		location_a = location_b[-1]-21+a_list[location_b[-1]-20:location_b[-1]+20].index(max(a_list[location_b[-1]-20:location_b[-1]+20]))		m += location_b[-1] - location_b[-2]		angle = (location_a -location_b[-1])* 2*math.pi/(location_b[-1] - location_b[-2])		position = angle*200		angular+=angle		twist.angular.z = position*0.02		if max(a_list[location_b[-1]-20:location_b[-1]+20])<100 and f:			twist.angular.z,twist.linear.x,f=0,0,0	print '%f'%(angular%(2*math.pi))	column+=twist.linear.x * math.cos(angular%(2*math.pi))*50	row+=twist.linear.x * math.sin(angular%(2*math.pi))*50	for i in range(20):		for j in range(20):			im.putpixel((int(round(column+i)),5000-int(round(row+j))),0)	position_pub.publish(position)	# actually publish the twist message	kobuki_velocity_pub.publish(twist)def line_follower():	# define the publisher globally	global kobuki_velocity_pub,a_pub,b_pub,position_pub	# initialize the node	rospy.init_node('line_follower', anonymous=True)	# initialize the publisher - to publish Twist message on the topic below...	kobuki_velocity_pub = rospy.Publisher('/mobile_base/commands/velocity', Twist, queue_size=10)	a_pub = rospy.Publisher('/mobile_base/commands/a', Int32, queue_size=10)	b_pub = rospy.Publisher('/mobile_base/commands/b', Int32, queue_size=10)	position_pub = rospy.Publisher('/mobile_base/commands/position', Int32, queue_size=10)	# subscribe to the topic '/ir_data' of message type Int32. The function 'ir_callback' will be called	# every time a new message is received - the parameter passed to the function is the message	rospy.Subscriber("/ir_data", Int32, ir_callback)	# spin() simply keeps python from exiting until this node is stopped	rospy.spin()# start the line followif __name__ == '__main__':	line_follower()im.save('gray.jpg')